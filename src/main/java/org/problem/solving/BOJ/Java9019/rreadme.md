9019 - 못 풀겠다
문자열 구현 으로 접근했는데
안되서 알고리즘 분류를 봤는데 BFS였다
구글링을해도 감도 못잡았다
언젠간 뽀사주겠다

+ 2024 08 31<br>
풀었다<br>
문제 파악까지 1시간, 구현부터 정답까지 50분 소요되었다<br>
BFS를 큐를 사용한 반복문으로 풀었으며<br>
처음에 스택과 했갈리지않았다면 더빨리 풀었을것 같다<br>
정석적인 BFS문제 이지만 정말 힘들게 풀었다<br>
D,S,L,R 계산은 자리를 옮긴다는것이 번거로울줄 알았는데<br>
특별한 개념없이 연산으로 처리 가능했디<br>
이 문제에서<br>
연산해야할 n번째 수 1234 가 있다면<br>
연사 명령어를 배열에 중첩하는데 배열의 인덱스를 수 로 사용했다<br>
  <br>
즉 ans[1234] 의 값에 D,S,L,R을 저장하는것이다<br>
어차피 값이 중복되면 연산이 무한 반복된다<br>
수 하나는 한번만 연산 되기때문에 수를 인덱스로 사용해 값을 저장해도 된다<br>
<br>
풀고보니 막 어려운 문제는 아니었다<br>

++ <br>
값을 B로 만들수 있는 규칙 같은것이 없으니 매번 DSLR을 해주는것 외에 시간을 줄일수는 없다<br>
그래서 10000 길이의 고정값을 가지고있는 배열을 다 사용하지않으니<br>
해시맵으로 매모리를 줄이는 방법을 고민 해봤다 > Java9019_2<br>
```
배열을 0부터 n까지 순차 탐색하는 문제였다면
해시맵이 매모리도 줄이고 시간도 단축 할 수 있겠지만
배열도 인덱스 값으로 한번만에 탐색 가능함으로
해시맵 사용으로 인한 이득은
필요한 키의 값만 저장하는 매모리 사용 감소가 이득이다
```
라고 생각했지만 시간 초과가 발생 했다<br>
해시맵 사용의 우려할 사항은 해시충돌 정도 였다 1만개의 버킷이 충돌 될리 없다고 생각했다<br>
충돌되어도 해시메서드가 알아서 충돌을 해결할것이고<br>
그래도 만약 이 코드가 샐패 한다면 오류,오답이 발생할것이라 예상했는데<br>
시간 초과가 발생 했다<br>
이유를 추측해보자면<br>

1. 해시값을 불러오는 절차가 배열값을 불러오는것보다 느릴경우.<br>
배열,해시맵 둘다 O(1)번만에 조회가 가능하기때문에 오답의 요건이 아닐것이다<br>

2. 해시맵에 값이 추가 될때마다 해시맵이 재배열 될 경우.<br>
한번의 while이 동작할때 해시맵에는 4개씩 9999개의 값이 추가 된다<br>
처음에 해시맵에 1개의 버킷으로 시작해 9999개 까지 증가할때 해시맵이 재구성(리해싱) 되는데<br>
이것을 결정하는것이 로드팩터(0.75)이다 4분의1이 넘어가면 리해싱 되며<br>
버킷수가 16 > 32 > ... 8192 > 16384 로 11번의 리해싱이 발생한다<br>
   <br>
결과적으로 해시맵이 너무 무거워 시간초과가 발생한것이다<br>



