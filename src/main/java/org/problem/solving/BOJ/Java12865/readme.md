dp의 대표적인 배낭문제로 유명하다고 한다
dp는 규칙을 찾아 반복하며 각 반복의 상태를 저장해나가며
다음 반복에서 저장한 값을 사용한다
하지만 이 문제는 그냥 다 시도해야 답을 도출 할수 있다고 생각했다
모든 물건을 넣은 상태, 뺀상태를 한번씩 N^2 번 해야 한다
가방의 최대 무게를 감안 하면 최대 무게를 넘어서지않는 경우만 시도하기때문에
시간 안에 풀수 있을것 같다
해결 방법을 찾을수 없어 검색해봤는데 역시 모든 경우를 시도하며 답을 구한다
단 특정 물건을 넣거나 넣지 않을때 dp에 저장된 최대값을 기준으로 연산하기때문에
dp문제였던 것이다
해답을 보며 구현,통과 했지만
최대값을 dp테이블에 갱신할때
어떤 최대 데이터를 참조하여 값을 갱신하야 하는것인지
이해하지못했기 때문에 나중에 스스로 구현할수 없을것이다
```
Math.max(dp[i - 1][w], dp[i - 1][w - weights[i]] + values[i])
에서 dp[i - 1][w - weights[i]] + 가치 와
dp[i - 1][w] 중 큰값으로 갱신하는데
무개를 뺀다(인덱스 이동), i-1 의 이유를 명확하게 알수 없디
```
이 문제에 대한 해결 구조를 이해하지못해 코드를 봐도 모르는것 같다
나중에 다시 풀어보자